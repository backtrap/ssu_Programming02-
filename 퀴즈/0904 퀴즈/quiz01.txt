#01
*p = 200, **q = 200, p = 0x2000, *q = 0x2000, q = 0x3000


#02
0x1000
10
10
0x1000
10


#03
*((double*)v)


#04
sizeof(*dp)는 double형 포인터 변수인 dp가 가리키는 변수의 자료형 크기를 리턴한다. 따라서 값으로 8을 갖는다.
sizeof(dp)는 double형 포인터 변수인 dp의 크기를 갖는다. 포인터 변수의 크기는 가리키는 자료형의 크기와 상관없이 (64bit 운영체제의 경우) 8byte이다. 따라서 값으로 8을 갖는다.


#05
c = *p;
*p = *q;
*q = c;


#06
(1)
주소 연산자 &는 상수 앞에 사용할 수 없다.

(2)
주소 연산자 &는 수식 앞에 사용할 수 없다.


#07
출력 결과 : 0x10c 0x118 0x103

상수 0x100을 int형 포인터, double형 포인터, char형 포인터로 캐스팅한 후 각각을 포인터 변수 p, q, r의 값으로 배정했다. 포인터 연산은 포인터 변수가 가리키는 자료형의 크기만큼 이루어진다. 따라서 p+3은 int형의 자료형 크기가 4byte이므로 0x100 + 3*4 = 0x10c이다. q+3은 double형의 자료형 크기가 8byte이므로 0x100 + 3*8 = 0x118이다. r+3은 char형의 자료형 크기가 1byte이므로 0x100 + 3*1 = 0x103이다.


#08
포인터 변수 p를 선언만 하고 값을 배정하지 않았다. 따라서 p는 가리키는 주소가 없으므로 *p를 이용해서 값을 배정할 수 없다. p를 이용해서 scanf()와 printf()를 사용하고 싶다면 int형 변수를 선언한 후 선언한 변수의 주소를 p의 값으로 배정한 후 사용하면 된다. 
