#01
첫 번째 printf()는 p의 값을 출력한다. 따라서 p의 값인 a, 즉 배열 a의 첫 번째 원소인 H의 주소를 출력한다
두 번째 printf()는 배열 a의 첫 번째 원소의 값을 unsigned int 형으로 출력한다. 따라서 H의 아스키 코드인 72가 출력된다.
세 번째 printf()는 포인터 변수 p가 가리키는 변수의 값을 unsigned int형으로 출력한다. 따라서 *a의 값과 똑같이 72가 출력된다.
네 번째 printf()는 p가 가리키는 변수의 주소로 간 후 포인터 연산 +1을 하고 해당 주소에 있는 값을 unsigned int형으로 출력한다. 따라서 배열 a의 첫 번째 원소의 주소로 간 후 포인터 연산 +1을 하여 두 번째 원소의 주소로 가서 두 번째 원소인 e의 아스키 코드 101을 출력한다. 
다섯 번째 printf()는 포인터 변수 p가 가리키는 변수의 값에 1을 더한 후 unsigned int형으로 출력한다. 따라서 H의 아스키 코드인 72에 1을 더한 값인 73이 출력된다.


#02
출력 결과는 hello!가 나온다.
"ghi"[1]은 문자열 상수 "ghi"의 두 번째 원소인 h를 의미한다.
*("def" + 1)은 문자열 상수 "def"의 두 번쨰 원소인 e를 의미한다.
*"abc"+11은 문자열 상수 "abc"의 첫 번째 원소인 a에 11을 더한 것을 의미한다. 변환 명세가 %c이므로 l이 출력된다.
"klm"[1]은 문자열 상수 "klm"의 두 번쨰 원소인 l을 의미한다.
*"ghi"+8은 문자열 상수 "ghi"의 첫 번째 원소인 g에 8을 더한 것을 의미한다. 변환 명세가 %c이므로 o가 출력된다.


#03
1) 0x608
2) 0x60c
3) 0x608
4) 0x600
5) 26
6) 0x608
7) 0x608
8) 0x608
9) 0x608
10) 0x608


#04
0x1004 0x2004 0x3008 0x4008 0x3008


#05
* 배열표현으로만 코드 작성
printf("%c %s\n", a[0][2][3], &a[1][2][2]);
* 포인터연산으로만 코드 작성
printf("%c %s\n", *(*(*a+1)+2), (*(*(a+1)+1)+2));


#06
10 8 12 40
f():sizeof(a) = 8

sizeof(s)의 경우 char형 배열의 원소의 개수가 출력된다. 널 문자까지 포함해서 문자가 총 10개 있고 char형의 크기는 1byte이므로 10이 출력된다.
sizeof(p)의 경우 포인터 변수 p의 크기가 출력된다. 64bit 운영체제에서 포인터 변수의 크기는 8byte로 동일하다.
sizeof(a)의 경우 int형 배열 a의 크기가 출력된다. 크기가 4byte인 int형 변수가 총 3개 있으므로 12가 출력된다.
sizeof(d)의 경우 double형 배열 d의 크기가 출력된다. 크기가 8byte인 double형 변수가 총 5개 있으므로 40이 출력된다.
f(a)는 8을 출력한다. main()에서 함수 f()로 매개 변수로 배열 a를 넘겼지만 이는 배열이 아니라 포인터 변수로 넘어갔기 때문에 포인터 변수의 크기에 맞춰 8이 출력된다. 


#07
#include <stdio.h>

int main() {
	char * fruit = "strawberry";

	char c;
	int num = 0;

	while (1) {
		c = *(fruit + num);

		if (c == '\0')
			break;
		
		printf("%c", c);
		
		num++;
		num++;
	}

	return 0;
}


#08
